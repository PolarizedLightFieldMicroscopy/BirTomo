{\rtf1\ansi\ansicpg1252\cocoartf2821
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fswiss\fcharset0 Helvetica-Bold;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww12720\viewh7800\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 Notes on simulated volumes:\
\

\f1\b 17Feb2025
\f0\b0 \
The volumes containing birefringent voxels were simulated using the Mathematica Notebook \
BirefrObjectForwardProjFeb2025.nb. The Notebook first generates a volume for X-axis imaging, which is the default imaging mode in this and related Notebooks. \
\
When saving an .h5 file with volume data, the data are first transposed for Z-axis imaging, using array conventions for python processing. For example, the indices i, j, k, in array[[i, j, k]] are in the order of Z, Y, X dimension in both, Mathematica and python conventions, but in Mathematica, vector indices are in order \{X, Y, Z\}, while in python they are in order [Z, Y, X].\
\
For python processing, the Mathematica optic axis array optic_axisMath[i,j,k,v] is transposed to optic_axisPyth[v, i, j, k], which has in its first position the three indices of the optic axis at position i, j, k, in order [v-Z, v-Y, v-X].\
\

\f1\b ThreeVoxBirCtrX_Feb14.h5
\f0\b0 \
optical_info/description -> three voxels extending along the X-axis and their optic axes in Z,Y,X orientations, generated with oLBall3Y, object box \{Z,Y,X\} = \{13, 17, 17\}\
\

\f1\b ThreeVoxBirCtrY_Feb17.h5
\f0\b0 \
optical_info/description -> three voxels extending along the Y-axis and their optic axes in Z,Y,X orientations, generated with oLBall3Z, object box \{Z,Y,X\} = \{13, 17, 17\}\
\
}